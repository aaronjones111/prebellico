#!/usr/bin/python

import pcapy
import socket
import netifaces
import sys
import os
import re
import time
import json
import cPickle as pickle
import sqlite3
import argparse
import logging
from datetime import datetime
from impacket import ImpactDecoder
from pcapy import findalldevs, open_live, PcapError
from operator import itemgetter
from itertools import groupby
from collections import defaultdict
import string
from pdb import set_trace as bp

# Parse arguments from user via argparse
parser = argparse.ArgumentParser()
parser.add_argument('-i', '--inf', help='Specify the interface you want Prebellico to listen on. By default Prebellico will hunt for interfaces and ask the user to specify an interface if one is not provided here.')
parser.add_argument('-f', '--file', help='Specify a PCAP file to read from instead of a network interface. By default Prebellico assumes that traffic is to be read from a network interface.')
parser.add_argument('-l', '--log', help='Specify an output file. By default Prebellico will log to "prebellico.out" if a logfile is not specified.')
parser.add_argument('-d', '--db', help='Specify an sqlite db file you want to write to. By default this will create, if need be, and write to "prebellico.db" if not specified by the user, as long as the file is an actual Prebellico DB that the user can read from.')
parser.add_argument('-e', '--extra', help='Specify extra filtering using PCAP based syntax. By default, "ip or arp or aarp and not host 0.0.0.0 and not host <interface_IP>" is used as a filter.')
parser.add_argument('-t', '--targets', help='Specify targets of interest.')
parser.add_argument('-w', '--wait', help='Specify a period of time in hours to wait for new intelligence before shifting to a new form of intelligence gathering.')
parser.add_argument('-s', '--subsume', help='Include traffic from the target interface from Prebellico output. By default this traffic is excluded to ensure data generated by the interface while interacting with the environment does not taint the "fingerprint" of the target environment.', action='store_true')
parser.add_argument('-p', '--semipassive', help='Perform semi-passive data collection after a specified period of time where no new passive intelligence is aquired.', action='store_true')
parser.add_argument('-a', '--semiaggressive', help='Perform semi-aggressive data collection after a specififed period of time where no new passive or semi-passive intelligence is aquired.', action='store_true')
parser.add_argument('-q', '--quiet', help='Remove the Prebellico banner at the start of the script.', action='store_true')

args = vars(parser.parse_args())

# Function to establish the name of the SQLite DB name, either as specified by the user, or using the default, and validating that it is a prebellico database which we can access.
def checkPrebellicoDb():
    sqliteDbFile=args['db']
    if sqliteDbFile is None:
        sqliteDbFile='prebellico.db'
    print("\nChecking for a '%s' database file.") % ( sqliteDbFile )
    if not os.path.exists(sqliteDbFile):
        print("\nThe '%s' database file does not exist. Creating a prebellico database now.") % ( sqliteDbFile )
        try:
            dbConnect=sqlite3.connect(sqliteDbFile)
            db=dbConnect.cursor()
            db.execute('create table prebellico(prebellicodb text)')
            db.execute('insert into prebellico values("prebellico_recon")')
            db.execute('create table tcpintelligence(host text)')
            db.execute('create table udpintelligence(host text)')
            db.execute('create table snmpstrings(string text)')
            db.execute('create table tcpipidnumbers(host text)')
            db.execute('create table zombiehosts(host text)')
            db.execute('create table arpintelligence(host text)')
            db.execute('create table icmpintelligence(host text)')
            db.execute('create table trustedintelligence(host text)')
            db.execute('create table knownnets(host text)')
            db.execute('create table mailslotbrowser(host text)')
            db.execute('create table externalhosts(host text)')
            db.execute('create table tcppshack(host text)')
            dbConnect.commit()
            print("\nThe '%s' prebellico database file has been created.") % ( sqliteDbFile )
            dbConnect.close()
        except sqlite3.OperationalError, msg:
            print msg
    else:
        print("\nThe '%s' database file exists. Working to confirm it's a prebellio database file and we have access to the database file.") % ( sqliteDbFile )
        try:
            dbConnect=sqlite3.connect(sqliteDbFile)
            db=dbConnect.cursor()
            db.execute('select * from prebellico')
            confirmPrebellicoDb=db.fetchone()[0]
            if confirmPrebellicoDb == "prebellico_recon":
                print("\nThe '%s' file is a prebellico database file.") % ( sqliteDbFile )
                dbConnect.close()
            else:
                print("\nThe '%s' file is not a prebellico database file:") % ( sqliteDbFile )
                print("\nPlease correct this issue and try again.")
                exit()
        except sqlite3.OperationalError, msg:
            print("\nThe '%s' file is not a prebellico database file:") % ( sqliteDbFile )
            print msg
            print("\nPlease correct this issue and try again.")
            exit()

# Function to log all the things so that data can easily be logged where the user wants it, ensuring that it is stored in a standard log, as well as the DB when needed.
def logAllTheThings(queryType, functionName, data):
    prebellicoDb(queryType, functionName, data)
    if queryType == write:
        prebellicoLog(functionName, data)
    return

# Function to open and close the DB, as well as return data as required
def prebellicoDb(queryType, functionName, data):
    dbConnect=sqlite3.connect(sqliteDbFile)
    db=dbConnect.cursor()
    dbConnect.close()

    # If the request is to read data from the DB, read the data, close the DB connection and return the data for output
    if queryType is 'read':
        # Select statements here

        # Close the database connection and return the selected data
        dbConnect.close()
        return(data)

    # If the request is to write data to the DB, post the data and close the connection
    elif queryType is 'write':
        # Write insert/update statements here

        # Close the database connection
        dbConnect.close()
        return
    else:
        print("Something went wrong while trying to interact with the %s database via the %s function! The query type was '%s' and the data was '%s'.") % ( sqliteDbFile, functionName, queryType, data )
        return

# Function to write data to the screen and prebellico log
def prebellicoLog(functionName, data):
    #Obtain the current date/time
    now = datetime.now()
    timestamp = str(now.strftime('%d-%b-%Y %H:%M:%S.%f'))
    logging.info(data)
    return

# Because everyone needs a cool banner - shown by default unless someone asks for it to be disabled
def prebellicoBanner():
    banner = """
       ___          __       _____        
      / _ \_______ / /  ___ / / (_)______ 
     / ___/ __/ -_) _ \/ -_) / / / __/ _ \\
    /_/  /_/  \__/_.__/\__/_/_/_/\__/\___/
    """
    print(banner)
    time.sleep(1)
    print("\nThere is no patch for passive recon. ;)\n")
    time.sleep(2)

# This just isn't working now. Need to rethink the data structure
# intelligence = [ {'host':'ip'}, {'hwaddr':'null'}, {'openports':'ports'}, {'os':'null'}, {'trustedhosts','null'}, ('vulns':'null'}, {'updatetime':'null'} ]
# intelligence = [ [ 'host', 'port' ] ]

# Define a data dictionary for open TCP ports using hosts as keys and ports as values
tcpintelligence = defaultdict(set)

# Define a data dictionary for open UDP ports using hsots as keys and ports as values
udpintelligence = defaultdict(set)

# Define a data dictionary for captured SNMP strings using the snmp string as the key and hosts as the value
snmpstrings = defaultdict(set)

# Define a data dictionary for TCP IPID squence numbers to look for zombie hosts
tcpipidnumbers = defaultdict(list)

# Define a data dictionary for zombie hosts
zombiehosts = defaultdict(set)

# Define a data dictonary for arp requests using the IP address as keys and their MAC address as values
arpintelligence = defaultdict(set)

# Define a data dictionary for icmp requests using the IP address as keys 
icmpintelligence = defaultdict(set)

# Define a data dictionary for trusted relationships based upon trusted TCP connections using the ip address of the host responding to a syn request as the key and the trusted host as the value
trustedintelligence = defaultdict(set)

# Define a data dictionary for known networks based upon the networks that source hosts appear to belong to.
knownnets = defaultdict(set)

# Define a data dictionary for external hosts based upon the internet hosts the internal hosts connect to.
externalhosts = defaultdict(set)
tcpnetworkegresspermitted = 0
udpnetworkegresspermitted = 0
icmpnetworkegresspermitted = 0

# Define a data dictionary for SMB Mailslot Browse intelligence using the host IP as the key
mailslotbrowser = defaultdict(set)

# Define a variable to control output of HSRP traffic - This is temporary until this is more built out.
HSRPnotification = 0

# Define a data dictionary for confirmed HSRP passwords using the password as a key and the host as a vaule
hsrppasswords = defaultdict(set)

# Define a data dictionary for TCP ACK's designed to confirm server to client ACK's affiliated with SMB PSH/ACK requests using the host IP as the key
tcppshack = defaultdict(set)

# Function to detect the protcol used within the packet to steer accordingly.
def inspectproto(header, data):

	# Start to decode the packet, determine the protocol number and call the appropriate method.
	#print("\nTop of the inspectproto method.\n")
	ethernet_packet = decoder.decode(data)
	protocolnumber = decoder.decode(data).child().child().protocol
	if protocolnumber == 1:
		#print("\nThis is an ICMP packet.")
		icmpdiscovery(header,data)
		return
	elif protocolnumber == 4:
		#print("\nThis is an IP packet.")
		return
	elif protocolnumber == 6:
		#print("\nThis is a TCP packet.")
		# Pull TCP flags to determine tcp session state so that we can determine what TCP method to call for intel. 
		tcp_syn = ethernet_packet.child().child().get_SYN()
		tcp_ack = ethernet_packet.child().child().get_ACK()
		tcp_ece = ethernet_packet.child().child().get_ECE()
		tcp_cwr = ethernet_packet.child().child().get_CWR()
		tcp_fin = ethernet_packet.child().child().get_FIN()
		tcp_psh = ethernet_packet.child().child().get_PSH()
		tcp_rst = ethernet_packet.child().child().get_RST()
		tcp_urg = ethernet_packet.child().child().get_URG()
		if ( tcp_syn == 1 and tcp_ack == 1 ):
		    synackdiscovery(header,data)
                if ( tcp_psh == 1 and tcp_ack == 1 or tcp_ack == 1):
                    tcppushdiscovery(header,data)
		tcpdiscovery(header,data)
		return
	elif protocolnumber == 17:
		#print("\nThis is a UDP packet.")
		udpdiscovery(header,data)
		return
	elif protocolnumber == 41:
		#print("\nThis is an IPv6 encapulated packet.")
		return
	elif protocolnumber == 43:
		#print("\nThis is an IPv6 routing header packet.")
		return
	elif protocolnumber == 44:
		#print("\nThis is an IPv6 fragment header packet.")
		return
	elif protocolnumber == 58:
		#print("\nThis is an IPv6 ICMP packet.")
		return
	elif protocolnumber == 59:
		#print("\nThis is an IPv6 no next header packet.")
		return
	elif protocolnumber == 60:
		#print("\nThis is an IPv6 destination options packet.")
		return
	# This is not an accurate catchall and will more than likely fail at some point
	elif protocolnumber == None:
		#print("\nThis is not an IP packet. More than likely ARP.")
		#arpheader = decoder.decode(data).child().get_op_name()
		#print("\nWe have an arp packet baby: %s!") % ( arpheader )
		return
	else:
		#print("\nThe protocol number in this packet is %s. This is not TCP.") % ( protocolnumber )
		#print("\nEnd of the inspectproto method.\n")
		return
		#pdb.set_trace()
		#sniff.next

# Function designed to sniff out intel tied to ICMP traffic
def icmpdiscovery(header,data):
	#print("\nStart of the icmpdiscovery method.\n")
	ethernet_packet = decoder.decode(data)
	protocolnumber = decoder.decode(data).child().child().protocol
	if protocolnumber != 1:
    	    return
	ip_hdr = ethernet_packet.child()
	source_ip = ip_hdr.get_ip_src()
	dest_ip = ip_hdr.get_ip_dst()
	icmp_hdr = ethernet_packet.child().child()
	unknownsourcenetwork = 0
	unknowndestnetwork = 0
	unknownexternalhost = 0
	hostexists = 0

	# Work to determine if this is an icmp echo or echo reply. This is important, as it will allow us to determine if ICMP is permitted egress for C2 uses.
	if ( icmp_hdr.get_type_name(icmp_hdr.get_icmp_type()) == "ECHO" ): 
		# For each host listed as a key in our data dictionary, compare the actual host to the key. If it matches, make note of it by setting hostexists to '1'
		for host in tcpintelligence.keys():
			if source_ip == host:
				hostexists = 1
		for host in udpintelligence.keys():
			if source_ip == host:
				hostexists = 1
		for host in icmpintelligence.keys():
			if source_ip == host:
				hostexists = 1
		if ( hostexists == 0 ):
			logging.info(("\n-=-ICMP Recon-=-\nIdentified a host through ICMP(%s): %s") % ( icmp_hdr.get_type_name(icmp_hdr.get_icmp_type()), source_ip ))
			icmpintelligence[source_ip].update(source_ip)
			#tcpintelligence[source_ip].add()
			#udpintelligence[source_ip].add()


		# Look to see if the IP address appears to belong to a set of known nets. If not alert the user of the known net and update the knownnets datadictionary - there is a bug here - I don't manage IPv6 properly yet.
		rfc1918addressregex = re.compile('^(127\.)|(192\.168\.)|(10\.)|(172\.1[6-9]\.)|(172\.2[0-9]\.)|(172\.3[0-1]\.)')#  Add this when IPv6 is ready: |(::1$)|([fF][cCdD])')
		sourcematch = rfc1918addressregex.match(source_ip)
		if sourcematch:# or destmatch:
			source_ip_octets = source_ip.split('.')
			source_network = source_ip_octets[0] + '.' + source_ip_octets[1] + '.' + source_ip_octets [2] + '.1/24'
			for known_network in knownnets.keys():
				if source_network == known_network:
					unknownsourcenetwork = 1
			if unknownsourcenetwork == 0 and sourcematch:
				logging.info(("\n-=-Network Recon-=-\nA new network has been identified: %s") % (source_network))
				knownnets[source_network].add(source_ip)

	if ( icmp_hdr.get_type_name(icmp_hdr.get_icmp_type()) == "ECHOREPLY" ): 
		# For each host listed as a key in our data dictionary, compare the actual host to the key. If it matches, make note of it by setting hostexists to '1'
		for host in tcpintelligence.keys():
			if source_ip == host:
				hostexists = 1
		for host in udpintelligence.keys():
			if source_ip == host:
				hostexists = 1
		for host in icmpintelligence.keys():
			if source_ip == host:
				hostexists = 1
		rfc1918addressregex = re.compile('^(127\.)|(192\.168\.)|(10\.)|(172\.1[6-9]\.)|(172\.2[0-9]\.)|(172\.3[0-1]\.)')#  Add this when IPv6 is ready: |(::1$)|([fF][cCdD])')
		sourcematch = rfc1918addressregex.match(source_ip)
		if ( hostexists == 0 and sourcematch):
			logging.info(("\n-=-ICMP Recon-=-\nIdentified a host through ICMP(%s): %s") % ( icmp_hdr.get_type_name(icmp_hdr.get_icmp_type()), source_ip))
			icmpintelligence[source_ip].update(source_ip)

		# Look to see if the IP address appears to belong to a set of known nets. If not alert the user of the known net and update the knownnets datadictionary - there is a bug here - I don't manage IPv6 properly yet.
		rfc1918addressregex = re.compile('^(127\.)|(192\.168\.)|(10\.)|(172\.1[6-9]\.)|(172\.2[0-9]\.)|(172\.3[0-1]\.)')#  Add this when IPv6 is ready: |(::1$)|([fF][cCdD])')
		sourcematch = rfc1918addressregex.match(source_ip)
		destmatch = rfc1918addressregex.match(dest_ip)
		if sourcematch:#destmatch:
			source_ip_octets = source_ip.split('.')
			source_network = source_ip_octets[0] + '.' + source_ip_octets[1] + '.' + source_ip_octets [2] + '.1/24'
			for known_network in knownnets.keys():
				if source_network == known_network:
					unknownsourcenetwork = 1
			if unknownsourcenetwork == 0 and sourcematch:
				logging.info(("\n-=-Network Recon-=-\nA new network has been identified: %s") % (source_network))
				knownnets[source_network].add(source_ip)

		# If a host does not match an RFC1918 address that an RFC1918 address is talking to note the external host and the internal host permitted to talk to it and notify the user about the permitted connection
		if not sourcematch and destmatch:
			global icmpnetworkegresspermitted
			if icmpnetworkegresspermitted == 0:
				logging.info("\n-=-Egress Recon-=-\nNetwork egress detected! Internal hosts are permitted to ping the internet.")
				icmpnetworkegresspermitted = 1
		#print("\nEnd of the icmpdiscovery method.\n")

# Function designed to sniff out intel tied to generic UDP intelligence such as SMB and SNMP traffic
def udpdiscovery(header,data):

	#print("\nStart of udpdiscovery method.\n")
	# Start to decode the packet and determine the protocol number. If not UDP, return as it does not apply here.
	ethernet_packet = decoder.decode(data)
	protocolnumber = decoder.decode(data).child().child().protocol
	if protocolnumber != 17:
		return 
	# Extract relevant data from the ethernet packet
	mac_hdr = ethernet_packet
	source_mac = mac_hdr.as_eth_addr(mac_hdr.get_ether_shost())
	dest_mac = mac_hdr.as_eth_addr(mac_hdr.get_ether_dhost())
	ip_hdr = ethernet_packet.child()
	udp_hdr = ip_hdr.child()
	source_ip = ip_hdr.get_ip_src()
	dest_ip = ip_hdr.get_ip_dst()
	udp_source_port = udp_hdr.get_uh_sport()
	udp_dest_port = udp_hdr.get_uh_dport()

	# Define control variables to control message output of discovered hosts
	hostexists = 0
	portexists = 0
	srcarpexists = 0
	dstarpexists = 0
	unknownsourcenetwork = 0
	unknowndestnetwork = 0
	unknownexternalhost = 0
	notnewsnmpstringhost = 0
	unknownmailslotbrowserhost = 0

	# Look to see if the IP address appears to belong to a set of known nets. If not alert the user of the known net and update the knownnets datadictionary - there is a bug here - I don't manage IPv6 properly yet.
	rfc1918addressregex = re.compile('^(127\.)|(192\.168\.)|(10\.)|(172\.1[6-9]\.)|(172\.2[0-9]\.)|(172\.3[0-1]\.)')#  Add this when IPv6 is ready: |(::1$)|([fF][cCdD])')
	sourcematch = rfc1918addressregex.match(source_ip)
	destmatch = rfc1918addressregex.match(dest_ip)
	if sourcematch or destmatch:
		source_ip_octets = source_ip.split('.')
		source_network = source_ip_octets[0] + '.' + source_ip_octets[1] + '.' + source_ip_octets [2] + '.1/24'
		dest_ip_octets = dest_ip.split('.')
		dest_network = dest_ip_octets[0] + '.' + dest_ip_octets[1] + '.' + dest_ip_octets[2] + '.1/24'
		if sourcematch:
			for known_network in knownnets.keys():
				if source_network == known_network:
					unknownsourcenetwork = 1
		if destmatch:
			for known_network in knownnets.keys():
				if dest_network == known_network:
					unknowndestnetwork = 1
		if unknownsourcenetwork == 0 and sourcematch:
			logging.info(("\n-=-Network Recon-=-\nA new network has been identified: %s") % (source_network))
			knownnets[source_network].add(source_ip)
		if unknowndestnetwork == 0 and destmatch:
			if source_network != dest_network:
				logging.info(("\n-=-Network Recon-=-\nA new network has been identified: %s") % (dest_network))
				knownnets[dest_network].add(dest_ip)

	# If a host does not match an RFC1918 address that an RFC1918 address is talking to note the external host and the internal host permitted to talk to it and notify the user about the permitted connection
	if not sourcematch and destmatch:
		global udpnetworkegresspermitted
		if udpnetworkegresspermitted == 0:
			logging.info("\n-=-Egress Recon-=-\nNetwork egress detected! Internal hosts are permitted to connect to the internet via UDP.")
			udpnetworkegresspermitted = 1
		for externalhost in externalhosts.keys():
			if source_ip == externalhost:
				unknownexternalhost = 1
		if unknownexternalhost == 0 and udpnetworkegresspermitted == 1:
			externalhosts[source_ip].add(dest_ip)
			logging.info(("\n-=-Egress Recon Update-=-\n%s is permitted to connect to %s on UDP port %s.") % (dest_ip, source_ip, udp_source_port))

	# For each host listed as a key in our host data dictionarys, compare the actual host to the key. If it matches, make note of it by setting hostexists to '1'
	if udp_source_port <= 8000:
		for host in udpintelligence.keys():
			if source_ip == host:
				hostexists = 1
		for externalhost in externalhosts.keys():
			if source_ip == externalhost:
				hostexists = 1
		for host in tcpintelligence.keys():
			if source_ip == host:
				hostexists = 1
	tempdata = udp_hdr.get_data_as_string()
	#print("\n\nudp_source_port = %s.") % ( udp_source_port)

	# If hostexists 0 and the source port is less than 8000, indicating a new host has been identified, notify the user and add the host and port to the data dictionary using the host as a key value
	if ( hostexists == 0 and udp_source_port <=8000 ):
		logging.info(("\n-=-Host Recon-=-\nA new host was identified with an open UDP port: %s:%s") % (source_ip, udp_source_port))
		arpintelligence[source_ip].add(source_mac)
		arpintelligence[dest_ip].add(dest_mac)
		udpintelligence[source_ip].add(udp_source_port)
		trustedintelligence[source_ip].add(dest_ip)

        #If we see someone scanning for SNMP using community strings, alert the user to the names that are used, and the source host that it is coming from. Typically this is a an IT/Security event, so this is attributed to 'Skynet'
        if udp_dest_port == 161:
            snmppacketfilterregex = re.compile('[a-zA-Z0-9.*].*')# Regex to yank data within snmp string data
            snmptempdata=snmppacketfilterregex.findall(tempdata)
            potentialSnmpStrings = re.split('[\x00-\x1f,\x7f-\xff]',snmptempdata[0])
            for justTheString in potentialSnmpStrings:
                if len(justTheString) >= 4:
                    communitystring = justTheString
                    logging.info(("\n-=-Skynet Recon-=-\nA %s is scanning for systems with an SNMPv1 community string: %s") % ( source_ip, communitystring ))

	# If we have a response from a host on port 161, notify the user and extract the SNMP string - note this is buggy as there is not SNMP packet verification
	if udp_source_port == 161:
		snmppacketfilterregex = re.compile('[a-zA-Z0-9.*].*(?=:)')# Regex to yank data before colon within snmp string data
		snmptempdata=snmppacketfilterregex.findall(tempdata)
                potentialSnmpStrings = re.split('[\x00-\x1f,\x7f-\xff]',snmptempdata[0])
                for justTheString in potentialSnmpStrings:
                    if len(justTheString) >= 4:
                        communitystring = justTheString
		if communitystring in snmpstrings.keys():
			for host in snmpstrings[string]:
				if host == source_ip:
					notnewsnmpstringhost = 1
				if notnewsnmpstringhost != 1:
					snmpstrings[communitystring].add(source_ip)
					logging.info(("\n-=-SNMP Recon Update-=-\n A new host has been identified which uses the '%s' SNMP community string: %s.\nThe following hosts are configured with this SNMP community string:\n") % ( communitystring, source_ip ))
					for host in snmpstrings[string]:
						logging.info(("%s, ") % ( host ),)
		else:
			logging.info(("\n-=-SNMP Recon-=-\nWe have a new SNMPv1 community string from %s: %s") % ( source_ip, communitystring )) 
			snmpstrings[communitystring].add(source_ip)

	# If we have an SMB packet, extract intelligence from this - this is going to be bigger than simply dumping the packets. Going to require classification of types of requests
	if ( udp_source_port == 138 ):
		for knownmailslotbrowserhost in mailslotbrowser.keys():
			if knownmailslotbrowserhost == source_ip:
				unknownmailslotbrowserhost = 1
		if unknownmailslotbrowserhost == 0:        
			mailslotmatch = re.search("\\MAILSLOT.*BROWSE", ethernet_packet.child().child().child().get_buffer_as_string(), re.MULTILINE)
			if mailslotmatch:
				mailslotstring = re.findall("(?<=\n\x00)(?!\x03\x90\x00)[\w\-\!\@\$\%\^\&\(\)\+\=\[\]\{\}\'\;\~\`]{1,15}(?=\x00)|(?<=\x0f\x01U\xaa)(?!\x03\x90\x00)[\w\s\:\-\=\_\-\+\[\]\{\}\!\@\#\$\%\^\&\*\(\)\'\"\:\;\~\`]+(?=\x00)", ethernet_packet.child().child().child().get_buffer_as_string(), re.MULTILINE)
				if len(mailslotstring) == 1:
					logging.info(('\n-=-SMB Recon-=-\nThe hostname for \'%s\' is \'%s\'') % ( source_ip, mailslotstring[0] ))
					mailslotbrowser[source_ip].add(mailslotstring[0])
				if len(mailslotstring) == 2:
					logging.info(('\n-=-SMB Recon-=-\nThe hostname for \'%s\' is \'%s\' and it describes itself as \'%s\'') % ( source_ip, mailslotstring[0], mailslotstring[1] ))
					mailslotbrowser[source_ip].add(mailslotstring[0])
					mailslotbrowser[source_ip].add(mailslotstring[1])

	# Work support for HSRP protocol
	global HSRPnotification
	if ( udp_source_port == 1985 and HSRPnotification != 1 ):
		logging.info('\n-=-Layer2/3 Recon-=-\nCisco HSRP is spoken here')
                HSRPnotification = 1
        if ( udp_source_port == 1985 ):
                unhashedHsrpPassword = 0
                hsrpPassExists = 0
                hsrptempdata = ethernet_packet.child().child().child().get_buffer_as_string()
                hsrppacketfilterregex = re.compile('[a-zA-Z0-9.*].*')# Regex to yank data within snmp string data
                hsrptempdata=hsrppacketfilterregex.findall(hsrptempdata)
                
                #Trying to work past a bug here for various types of HSRP packets. This doesn't really work to pull the hashed value, but manages a crash. Need to resolve this issue somehow.
                try: 
                    potentialHsrpPass = re.split('[\x00-\x1f,\x7f-\xff]',hsrptempdata[0])
                    for justTheString in potentialHsrpPass:
                        if len(justTheString) >= 4:
                            hsrppass = justTheString
                            if len(hsrppass) == 32:
                                md5detect = re.fullmatch('[a-zA-Z0-9.*]{32}')
                                if md5detect is not None:
                                    logging.info(('\n-=-Layer2/3 Recon-=-\nWe have an HSRP packet with either an MD5 hashed password or a raw password: %s') % ( hsrppass ))
                                else:
                                    unhashedHsrpPassword = 1
                            else:
                                unhashedHsrpPassword = 1
                    for storedHsrpPass in hsrppasswords.keys():
                        if storedHsrpPass == hsrppass:
                                hsrpPassExists = 1
                    if ( unhashedHsrpPassword == 1 and hsrpPassExists == 0 ):
                        logging.info(('\n-=-Layer2/3 Recon-=-\nWe have an HSRP packet with an unhashed password: %s') % ( hsrppass ))
                        hsrppasswords[hsrppass].add(source_ip)
                except:
                    pass
		#print('\n-=-Layer2/3 Recon-=-\nWe have an HSRP packet:\n%s\n\n\n\n%s\n\n\n\n%s\n') % ( ethernet_packet.child().child().child().get_buffer_as_string(), ethernet_packet.child().child().child(), data )
	#print("\nEnd of udpdiscovery method.\n")
	return

# Function designed to sniff out intel tied to captured TCP PSH requests 
def tcppushdiscovery(header,data):

	#print("\nStart of tcppushdiscovery method.\n")
	# Start to decode the packet and determine the protocol number. If not TCP, return as it does not apply here.
	ethernet_packet = decoder.decode(data)
	protocolnumber = decoder.decode(data).child().child().protocol
	if protocolnumber != 6:
		return 
	# Extract relevant data from the ethernet packet
	mac_hdr = ethernet_packet
	ip_hdr = ethernet_packet.child()
	tcp_hdr = ip_hdr.child()
	source_ip = ip_hdr.get_ip_src()
	source_port = tcp_hdr.get_th_sport()
        dest_ip = ip_hdr.get_ip_dst()
	dest_port = tcp_hdr.get_th_dport()

        # Pull TCP flags to determine tcp session state so that we can determine what TCP method to call for intel. 
	tcp_syn = ethernet_packet.child().child().get_SYN()
	tcp_ack = ethernet_packet.child().child().get_ACK()
	tcp_ece = ethernet_packet.child().child().get_ECE()
	tcp_cwr = ethernet_packet.child().child().get_CWR()
	tcp_fin = ethernet_packet.child().child().get_FIN()
	tcp_psh = ethernet_packet.child().child().get_PSH()
	tcp_rst = ethernet_packet.child().child().get_RST()
	tcp_urg = ethernet_packet.child().child().get_URG()

        if ( tcp_psh == 1 and tcp_ack == 1 ):
            portexists = 0
            #print("\n\nTCP PSH/ACK packet. Source port:%s Dest port:%s") % ( source_port, dest_port )
            if ( source_port <= 1024 and dest_port > 1024 ):
                # Using the source ip address as a key within the data dictionary, for each port listed see if it matches the source port captured witin the packet. If it is a match, set 'poretexists' to one to indicate we have seen this before.
	        for port in tcpintelligence[source_ip]:
		    if source_port == port:
		        portexists = 1
                if portexists == 0:
                    logging.info(("\n-=-TCP Push discovery-=-\nThere appears to be an open TCP port on %s:%s, which is talking to %s.") % ( source_ip, source_port, dest_ip ))
		    tcpintelligence[source_ip].add(source_port)
		    trustedintelligence[source_ip].add(dest_ip)
                return
            if ( source_port > 1024 and dest_port <= 1024 ):
                # Using the source ip address as a key within the data dictionary, for each port listed see if it matches the source port captured witin the packet. If it is a match, set 'poretexists' to one to indicate we have seen this before.
	        for port in tcpintelligence[dest_ip]:
		    if dest_port == port:
		        portexists = 1
                if portexists == 0:
                    logging.info(("\n-=-TCP Push discovery-=-\n%s appears to be talking to an open TCP port - %s:%s.") % ( source_ip, dest_ip, dest_port ))
		    tcpintelligence[source_ip].add(source_port)
		    trustedintelligence[source_ip].add(dest_ip)
		tcpintelligence[dest_ip].add(dest_port)
		trustedintelligence[dest_ip].add(source_ip)
                return
            if ( source_port > 1024 and dest_port > 1024 ):
                logging.info(("\n-=-TCP Push discovery-=-\nThere appears to be a TCP based conversation between %s:%s and %s:%s. Consulting intelligence to see if we can identify which host has a listening TCP service.") % ( source_ip, source_port, dest_ip, dest_port ))
                #Need to work this algorithm a bit more but colon separated datadict values with a split comparison to the host might work. For now we just announce it and return
                #source_ip_and_dest_port = 'source_ip' + ':' + 'dest_port'
                #tcppshack[dest_ip].add(source_ip_adn_dest_port)
                #tcppshack = defaultdict(set)
                return
        #print("\nEnd of tcppushdiscovery method.\n")


# Function designed to sniff out intel tied to generic TCP intelligence such as predictable IPID numbers        
def tcpdiscovery(header,data):

	#print("\nStart of tcpdiscovery method.\n")
	# Start to decode the packet and determine the protocol number. If not TCP, return as it does not apply here.
	ethernet_packet = decoder.decode(data)
	protocolnumber = decoder.decode(data).child().child().protocol
	if protocolnumber != 6:
		return 
	# Extract relevant data from the ethernet packet
	mac_hdr = ethernet_packet
	ip_hdr = ethernet_packet.child()
	tcp_hdr = ip_hdr.child()
	source_ip_sequence_number = tcp_hdr.get_th_seq()
	source_ip = ip_hdr.get_ip_src()
	# Get a count of ipid sequence numbers
	ipidcount = len(tcpipidnumbers[source_ip])
	# Once we have three IPID sequence numbers, look for predictability and clean the list of ipid sequence numbers to preserve memory
	if ipidcount == 12:
		oldzombiehost = 0
		ipiditem = 0
		olddiffipid = 0
		diffpidmatch = 0
		while ipiditem <= 10:
			newdiffipid = tcpipidnumbers[source_ip][ipiditem] - tcpipidnumbers[source_ip][ipiditem + 1]
			if olddiffipid == newdiffipid:
				diffpidmatch += 1
				for zombiehost in zombiehosts.keys():
					if zombiehost == source_ip:
						oldzombiehost = 1
			olddiffipid = newdiffipid
			ipiditem += 1
		if ( oldzombiehost == 0 and diffpidmatch >= 10 ):
			logging.info(("\n-=-Zombie Recon-=-\n%s uses predictible IPID sequence numbers! Last difference:%s. Captured IPID sequence numbers:\n%s\n") % ( source_ip,newdiffipid,tcpipidnumbers[source_ip] ))
			for ipidnumber in tcpipidnumbers[source_ip]:
				zombiehosts[source_ip].add(ipidnumber)
		# Clean the list of ipid sequence numbers to preserve memory
		ipidmaster = tcpipidnumbers[source_ip][11]
		del tcpipidnumbers[source_ip]
		tcpipidnumbers[source_ip].append(ipidmaster)
	if source_ip_sequence_number != 0:
		tcpipidnumbers[source_ip].append(source_ip_sequence_number)
	#print("\nEnd of tcpdiscovery method.\n")
	return

# Function designed to sniff out the TCP syn/ack portion of the three way handshake to enumerate listing services for a host
def synackdiscovery(header, data):

	#print("Top of synackdisccovery method.")
	# Start to decode the packet and determine the protocol number. If not TCP, return as it does not apply here.
	ethernet_packet = decoder.decode(data)
	protocolnumber = decoder.decode(data).child().child().protocol
	if protocolnumber != 6:
		return 

	# Extract relevant data from the ethernet packet
	mac_hdr = ethernet_packet
	source_mac = mac_hdr.as_eth_addr(mac_hdr.get_ether_shost())
	dest_mac = mac_hdr.as_eth_addr(mac_hdr.get_ether_dhost())
	ip_hdr = ethernet_packet.child()
	tcp_hdr = ip_hdr.child()
	source_port = tcp_hdr.get_th_sport()
	dest_port = tcp_hdr.get_th_dport()
	source_ip_sequence_number = tcp_hdr.get_th_seq()
	source_ip = ip_hdr.get_ip_src()
	dest_ip = ip_hdr.get_ip_dst()

	# Define control variables to control message output of discovered hosts
	hostexists = 0
	portexists = 0
	srcarpexists = 0
	dstarpexists = 0
	unknownsourcenetwork = 0
	unknowndestnetwork = 0
	unknownexternalhost = 0

	# Look to see if the IP address appears to belong to a set of known nets. If not alert the user of the known net and update the knownnets datadictionary - there is a bug here - I don't manage IPv6 properly yet.
	rfc1918addressregex = re.compile('^(127\.)|(192\.168\.)|(10\.)|(172\.1[6-9]\.)|(172\.2[0-9]\.)|(172\.3[0-1]\.)')#  Add this when IPv6 is ready: |(::1$)|([fF][cCdD])')
	sourcematch = rfc1918addressregex.match(source_ip)
	destmatch = rfc1918addressregex.match(dest_ip)
	if sourcematch or destmatch:
		source_ip_octets = source_ip.split('.')
		source_network = source_ip_octets[0] + '.' + source_ip_octets[1] + '.' + source_ip_octets [2] + '.1/24'
		dest_ip_octets = dest_ip.split('.')
		dest_network = dest_ip_octets[0] + '.' + dest_ip_octets[1] + '.' + dest_ip_octets[2] + '.1/24'
		if sourcematch:
			for known_network in knownnets.keys():
				if source_network == known_network:
					unknownsourcenetwork = 1
		if destmatch:
			for known_network in knownnets.keys():
				if dest_network == known_network:
					unknowndestnetwork = 1
		if unknownsourcenetwork == 0 and sourcematch:
			logging.info(("\n-=-Network Recon-=-\nA new network has been identified: %s") % (source_network))
			knownnets[source_network].add(source_ip)
		if unknowndestnetwork == 0 and destmatch:
			if source_network != dest_network:
				logging.info(("\n-=-Network Recon-=-\nA new network has been identified: %s") % (dest_network))
				knownnets[dest_network].add(dest_ip)

	# If a host does not match an RFC1918 address that an RFC1918 address is talking to note the external host and the internal host permitted to talk to it and notify the user about the permitted connection
	if not sourcematch and destmatch:
		global tcpnetworkegresspermitted
		if tcpnetworkegresspermitted == 0:
			logging.info(("\n-=-Egress Recon-=-\nNetwork egress detected! Internal hosts are permitted to connect to the internet via TCP."))
			tcpnetworkegresspermitted = 1
		for externalhost in externalhosts.keys():
			if source_ip == externalhost:
				unknownexternalhost = 1
		if unknownexternalhost == 0 and tcpnetworkegresspermitted == 1:
			externalhosts[source_ip].add(dest_ip)
			logging.info(("\n-=-Egress Recon Update-=-\n%s is permitted to connect to %s on TCP port %s.") % (dest_ip, source_ip, source_port))

	# For each host listed as a key in our data dictionary, compare the actual host to the key. If it matches, make note of it by setting hostexists to '1'
	for host in tcpintelligence.keys():
		if source_ip == host:
			hostexists = 1
	for externalhost in externalhosts.keys():
		if source_ip == externalhost:
			hostexists = 1
	for host in udpintelligence.keys():
		if source_ip == host:
			hostexists = 1

	# If hostexists 0, indicating a new host has been identified, notify the user and add the host and port to the data dictionary using the host as a key value
	if hostexists == 0:
		logging.info(("\n-=-Host Recon-=-\nA new host was identified with an open TCP port: %s:%s") % (source_ip, source_port))
		arpintelligence[source_ip].add(source_mac)
		arpintelligence[dest_ip].add(dest_mac)
		tcpintelligence[source_ip].add(source_port)
		trustedintelligence[source_ip].add(dest_ip)
		return

	# Using the source ip address as a key within the data dictionary, for each port listed see if it matches the source port captured witin the packet. If it is a match, set 'poretexists' to one to indicate we have seen this before.
	for port in tcpintelligence[source_ip]:
		if source_port == port:
			portexists = 1
	for externalhost in externalhosts.keys():
		if source_ip == externalhost:
			portexists = 1

	# If the port from the source host is a new port, notify the user about the connect, update the data dictionary and list all the ports we know are open for this host as well as the hosts permitted to connect to it
	if portexists == 0:
		logging.info(("\n-=-Host Recon Update-=-\nA new open TCP port was discovered for %s. This host has the following open TCP ports:") % (source_ip)),
		tcpintelligence[source_ip].add(source_port)
		trustedintelligence[source_ip].add(dest_ip)
		for port in sorted(tcpintelligence[source_ip]):
		        logging.info(port)
		logging.info(("\n\n-=-Trust Intelligence-=-\nThe following host(s) are permitted to talk to %s:") % (source_ip),)  
		for trust in trustedintelligence[source_ip]:
			logging.info(trust)
	#with open('prebellico_output.csv', 'w') as outfile:
		#json.dumps(tcpintelligence, outfile, sort_keys=True, indent=4)
		#json.dumps(arpintelligence, outfile, sort_keys=True, indent=4)
		#json.dumps(icmpintelligence, outfile, sort_keys=True, indent=4)
		#json.dumps(trustedintelligence, outfile, sort_keys=True, indent=4)
		#json.dumps(knownnets, outfile, sort_keys=True, indent=4)
		#json.dumps(externalhosts, outfile, sort_keys=True, indent=4)
		#json.dumps(, outfile, sort_keys=True, indent=4)

	#with open('prebellico_output.txt', 'w') as outfile:
		#outfile.write(pickle.dumps(tcpintelligence))
		#outfile.write(pickle.dumps(arpintelligence))
		#outfile.write(pickle.dumps(icmpintelligence))
		#outfile.write(pickle.dumps(trustedintelligence))
		#outfile.write(pickle.dumps(knownnets))
		#outfile.write(pickle.dumps(externalhosts))

	#print("\nEnd of synackdiscovery method.\n")
	return
	#pdb.set_trace()

def getInterface():
    # Grab a list of interfaces that pcap is able to listen on.
    # The current user will be able to listen from all returned interfaces,
    # using open_live to open them.
    print '\nSearching the system for compatible devices.'
    ifs = findalldevs()

    # No interfaces available, abort.
    if 0 == len(ifs):
        print "\nYou don't have enough permissions to open any interface on this system."
        sys.exit(1)

    # Only one interface available, use it.
    elif 1 == len(ifs):
        print "\nOnly one interface present, defaulting to it."
        return ifs[0]

    # Ask the user to choose an interface from the list.
    else:
        print "\nNumerous compatible interfaces identified:\n"
        count = 0
        for iface in ifs:
            try:
                t=open_live(iface, 1500, 0, 100)
                if( t.getnet() != '0.0.0.0' and t.datalink() ==  pcapy.DLT_EN10MB ):
                    print '%i - %s' % (count, iface)
                    count += 1
            except PcapError, e:
                break
    idx = int(raw_input("\nPlease select an interface you would like to use:"))
    return ifs[idx]

# Function to gather interface information and set the interface in sniffing mode if an interface is provided or selected during runtime.
def sniffInterface(dev):
    # Obtain the selected interface IP to use as a filter, allowing us to pwn all the things without pissing in prebellico's data pool
    devip = netifaces.ifaddresses(dev)[2][0]['addr']

    # Place the ethernet interface in promiscuous mode, capturing one packet at a time with a snaplen of 1500
    print("\nPlacing the '%s' interface in sniffing mode.") % ( dev )
    sniff = pcapy.open_live(dev, 1500, 1, 100)
    print "\nListening on %s: IP = %s, net=%s, mask=%s, linktype=%d" % (dev, devip, sniff.getnet(), sniff.getmask(), sniff.datalink())
    time.sleep(1)
    return(devip, sniff)

# Function to read from a pcap file if an interface is not defined and a PCAP file is provided to read from
# Note that the PCAP frame size has to be 262144 or lower by design per https://github.com/the-tcpdump-group/libpcap/commit/f983e075fbef40fe12323c4dd8f85c88eaf0f789 
def sniffFile(pcapFile):    
    print("\nOpening the %s PCAP file for processing.") % ( pcapFile )
    sniff=pcapy.open_offline( pcapFile )
    time.sleep(1)
    return(sniff)

# Call the prebellico banner if the user has not disabled this function
showBanner=args['quiet']
if showBanner is False:
    prebellicoBanner()

# Check the prebellico database
checkPrebellicoDb()

# Setting logging parameters
logfile=args['log']
if logfile is None:
    logging.basicConfig(filename='prebellico.log', format='%(message)s', level=logging.INFO)
else:
    logging.basicConfig(filename=logfile, format='%(message)s', level=logging.INFO)
console = logging.StreamHandler()
logging.getLogger('').addHandler(console)

# Determine if a device or file has been specififed. If the user requested to listen from a file instead of a network interface, ensure that both are not used. If a device or file has not been specified, hunt for compatible devices and ask the user to select a compatible device - Note, this is a bit of a hack, but it works.
dev=args['inf']
readPcapFile=args['file']
if readPcapFile is not None and dev is not None:
    print("\nReading from both a PCAP file and sniffing from an interface at the same time is not permitted. Consider processing the PCAP before or after sniffing from a live interface, refrencing the same Prebellico database.")
    exit()
if readPcapFile is not None and dev is None:
    sniff = sniffFile(readPcapFile)
if readPcapFile is None and dev is None:
    print("\nAn interface or a PCAP file was not provided.")
    dev = getInterface()
if readPcapFile is None and dev is not None:
    ( devip, sniff) = sniffInterface(dev)

# Set a filter for data based upon user preferences.
includeInterface=args['subsume']
extraPcapSyntax=args['extra']
filter = ("ip or arp or aarp and not host 0.0.0.0")
if includeInterface is False and readPcapFile is None:
   filter = filter + (" and not host %s") % ( devip )
if extraPcapSyntax is not None:
    filter = filter + (" %s") % ( extraPcapSyntax.lstrip() )
print("\nSetting filter syntax: %s.") % ( filter )
try:
    sniff.setfilter(filter)
except PcapError, e:
    print("\nSomething is wrong with your PCAP filter syntax: %s") % (e)
    print("\nPlease correct these issues and try again.")
    exit()

# Start the impact packet decoder
print("\nWatching for relevant intelligence.\n")
decoder = ImpactDecoder.EthDecoder()
time.sleep(1)

# Call the inspectproto function to determine protocol support
sniff.loop(0, inspectproto)
#try:
#    sniff.loop(0, inspectproto)
#except:
#    exit(0)

